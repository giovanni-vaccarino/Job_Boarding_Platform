\section{Backend}
This section provides an overview of the source code structure for the backend of the platform. The code is organized into three main layers: \textbf{Business}, \textbf{Data}, and \textbf{Service}, each serving a distinct purpose. Additionally, a \textbf{Shared} directory contains common utilities and resources.

\subsection{Business Layer}
The \textbf{Business} layer is responsible for handling the business logic of the application. This layer is structured to follow the \textbf{Command Query Responsibility Segregation (CQRS)} pattern. The organization is as follows:

\begin{itemize}
    \item For each section of the application (e.g., \textit{Authentication}, \textit{Internship}, \textit{Student}, etc.), there is a dedicated folder.
    \item Within each section folder, the relevant \textbf{use cases} are implemented. 
    \item Each use case folder contains:
    \begin{itemize}
        \item The \textbf{Command} or \textbf{Query}: These define the data and parameters required for executing the use case, and also its return value.
        \item The corresponding \textbf{Use Case}: This contains the logic for processing the command or query.
    \end{itemize}
\end{itemize}

\subsection{Data Layer}
The \textbf{Data} layer manages all database-related configurations and entity definitions. It is organized as follows:

\begin{itemize}
    \item A file for the \textbf{database setup}, which includes configuration settings, database initialization. This file also handles \textbf{entity relations} and cascading policies, ensuring proper database constraints and relationships.
    \item A folder named \texttt{Entities}, which contains the definitions of all the \textbf{entities} in the application. Each entity corresponds to a table in the database and includes properties and navigation relationships. Each entity extends the \textbf{EntityBase}, that represents the base properties of an entity: an \textbf{autogenerated ID}, a \textbf{createdDate} and an \textbf{updatedDate}
\end{itemize}

\subsection{Service Layer}
The \textbf{Service} layer serves as the interaction point between the application and the external users or systems. This layer includes:

\begin{itemize}
    \item A \texttt{Contracts} folder containing the \textbf{DTOs (Data Transfer Objects)}, which are organized into subfolders corresponding to each section (e.g., \textit{Authentication}, \textit{Internship}, etc.).
    \item A \texttt{Controllers} folder that includes all the \textbf{controllers} responsible for processing HTTP requests and returning responses.
    \item A \texttt{Middlewares} folder that contains any middlewares or policies(for authorization)
\end{itemize}

\subsection{Shared Folder}
Outside the main three layers, a \textbf{Shared} folder contains resources and utilities that are reused across the application. This includes:

\begin{itemize}
    \item A folder named \texttt{Enums}, which holds all the \textbf{enumerations} used throughout the application.
    \item A folder named \texttt{Services}, which contains shared services such as:
    \begin{itemize}
        \item The \textbf{Storage Service} for handling file uploads and storage operations.
        \item The \textbf{Email Service} for sending emails.
        \item The \textbf{Background Matching Job Service}, a folder that contains many files for handling the matching background job.
    \end{itemize}
\end{itemize}


\section{Frontend}
This section provides an overview of the source code structure for the frontend of the platform. The code has many files in the root folder, that handle for example routing or theming, but the core of the code is organized into several directories:

\subsection{Pages Folder}
The \texttt{pages} folder contains all the \textbf{pages} of the application. Each page represents a distinct view or route, such as the login page, home page, or internship details page.

\subsection{Components Folder}
The \texttt{components} folder contains all the \textbf{reusable UI components} in the application. The components are further categorized into subfolders based on their type, such as:
\begin{itemize}
    \item \texttt{layout}: Components related to the layout, such as headers, footers, and sidebars.
    \item \texttt{buttons}: Custom button components used across the application.
    \item \texttt{list-items}: Components for rendering lists and list items.
    \item Other types of reusable components.
\end{itemize}

\subsection{Hooks Folder}
The \texttt{hooks} folder contains all the \textbf{custom hooks} created for the application. These hooks are often wrappers that encapsulate reusable logic.

\subsection{Models Folder}
The \texttt{models} folder is used to define all the \textbf{interfaces and types} for the application's data models. For example:
\begin{itemize}
    \item \texttt{auth}: Contains interfaces/types related to authentication, such as login payloads or user models.
    \item \texttt{application}: Contains interfaces/types for internship applications.
\end{itemize}
Since we are working in TypeScript, this folder is crucial to have a specific point where to define our types.

\subsection{Core Folder}
The \texttt{core} folder contains essential services and utilities that form the core infrastructure of the frontend. It is structured as follows:

\begin{itemize}
    \item \texttt{config}: This folder contains files for setting up and managing the \textbf{configuration service}.
    \item \texttt{ioc}: This folder is dedicated to \textbf{inversion of control (IoC)} and is set up using \texttt{Inversify}. It manages dependency injection across the application.
    \item \texttt{store}: This folder is used for \textbf{Redux state management}. It includes:
    \begin{itemize}
        \item Configuration files for setting up the Redux store.
        \item A \texttt{slices} folder, where each slice represents a distinct piece of application state, such as authentication state or internship data.
    \end{itemize}
    \item \texttt{API}: This folder handles API-related logic. It is further divided into:
    \begin{itemize}
        \item \texttt{setup-api}: Contains files for setting up the API infrastructure, including factories and decorators.
        \item Subfolders for each API (e.g., \texttt{auth}, \texttt{internship}), where each subfolder includes:
        \begin{itemize}
            \item An \textbf{interface} defining the API contract(e.g IInternshipApi).
            \item One or more \textbf{implementations} of the API(e.g InternshipApi).
        \end{itemize}
    \end{itemize}
\end{itemize}

\section{Patterns and Architectural Choices}

This section explains the design patterns and architectural principles adopted across both the backend and frontend, where we have always tried to follow the \textbf{SOLID} principles.

\subsection{Backend}

\begin{itemize}
    \item \textbf{Dependency Injection (DI)}: Dependency Injection is used to manage dependencies, promoting loose coupling between components, simplifying testing.
    
    \item \textbf{Command Query Responsibility Segregation (CQRS)}: The CQRS pattern is used in the \textbf{Business Layer}, where commands and queries are handled separately. This allows for better scalability and separation of responsibilities.

    \item \textbf{Mediator}: The Mediator pattern is used to coordinate communication between different components, especially in the context of processing use cases.

    \item \textbf{Mapper}: A mapper is employed to handle conversions between \textbf{entities} and \textbf{DTOs (Data Transfer Objects)}, ensuring that the data structure used in the service layer and data layer remains consistent.
\end{itemize}

\subsection{Frontend}
\begin{itemize}
    \item \textbf{Dependency Injection (DI)}: Dependency Injection is implemented using \texttt{Inversify} to manage services and dependencies across the application.

    \item \textbf{Builder}: The builder pattern is utilized in the setup for the configuration service.

    \item \textbf{Factory}: Factories are used to create instances of various services, including API setup.

    \item \textbf{Decorator}: Decorators are applied for instance to API setup, in order to decorate the HttpClient to handle RefreshToken procedures.

    \item \textbf{State Management (Redux)}: The \textbf{store} directory utilizes Redux for managing global application state. Redux slices represent different parts of the state, such as authentication.
\end{itemize}

